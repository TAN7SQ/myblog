{"meta":{"title":"TAN's Blog","subtitle":"","description":"this is TAN7 blog","author":"TAN7","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-05-06T10:40:55.782Z","updated":"2023-05-06T10:40:55.782Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-05-06T10:41:19.227Z","updated":"2023-05-06T10:41:19.227Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"6-5 PWM驱动LED、舵机、直流电机","slug":"04-定时器/6-5 PWM驱动LED、舵机、直流电机","date":"2023-05-12T13:46:15.709Z","updated":"2023-05-12T13:43:06.113Z","comments":true,"path":"2023/05/12/04-定时器/6-5 PWM驱动LED、舵机、直流电机/","link":"","permalink":"http://example.com/2023/05/12/04-%E5%AE%9A%E6%97%B6%E5%99%A8/6-5%20PWM%E9%A9%B1%E5%8A%A8LED%E3%80%81%E8%88%B5%E6%9C%BA%E3%80%81%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/","excerpt":"","text":"[[6-4TIM输出比较]]PWM呼吸灯 RCC开启时钟，把TIM外设和GPIO外设的时钟打开 配置时基单元，包括前面的时钟源和时基单元 配置输出比较单元 CCR的值、输出比较模式、极性选择、输出使能（在结构体同一配置） 配置GPIO，将PWM对应的GPIO口，初始化为复用推挽输出的配置 运行控制 库函数 配置4个比较单元 TIM_OCxInit() TIM_ForcedOCxConfig 用于配置强制输出模式 TIM_OC1PreloadConfig用于配置CCR寄存器的预装功能，也就是影子寄存器 TIM_SetComparex用于更改PWM占空比 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;stm32f10x.h&quot; // Device headervoid PWM_Init(void)&#123;//前面这些初始化TIM2时钟的代码都不需要删除 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);// GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);// GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //为什么输出模式选择复用推挽输出？ //因为引脚的控制权来自于输出数据寄存器 //如果想让定时器来控制引脚，那么就使用复用推挽输出，将控制权转移到片上外设 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //此处改为PIN0 //GPIO_Pin_15; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); TIM_InternalClockConfig(TIM2); TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 100 - 1; //ARR TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1; //PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);//以上这些都是在6-2定时器就已经配置过// 注意在结构体中有些变量是只在高级定时器才有// 在变量前拿带有‘N’ TIM_OCInitTypeDef TIM_OCInitStructure; //这个结构体初始化的函数是给定时器赋初始值，防止在使用通用定时器时出现没有赋值的结构体变量导致的结构体的值出现混乱 TIM_OCStructInit(&amp;TIM_OCInitStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //输出比较的模式 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //High，选择输出的有效值是高电平 //设置输出比较的极性 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //设置输出使能 TIM_OCInitStructure.TIM_Pulse = 0; //占空比 //设置CCR TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure); TIM_Cmd(TIM2, ENABLE); //启动定时器，PWM波形就能通过引脚输出了&#125;void PWM_SetCompare1(uint16_t Compare)&#123; TIM_SetCompare1(TIM2, Compare); //用于更改占空比的值&#125; 为什么输出模式选择复用推挽输出？因为引脚的控制权来自于输出数据寄存器 如果想让定时器来控制引脚，那么就使用复用推挽输出，将控制权转移到片上外设 1234567891011121314151617181920212223uint8_t i;int main(void)&#123; OLED_Init(); PWM_Init(); while (1) &#123; for (i = 0; i &lt;= 100; i++) &#123; PWM_SetCompare1(i); Delay_ms(10); &#125; for (i = 0; i &lt;= 100; i++) &#123; PWM_SetCompare1(100 - i); Delay_ms(10); &#125; &#125;&#125; 引脚重映射 如果我们既要使用USART2的TX引脚，又要使用TIM2的CH3引脚，此时引脚冲突了，那么我们就可以在重映射列表中寻找这个引脚的重映射对应的引脚 比方说这里的PA2可以用PB10来重映射 GPIO_PinRemapConfig引脚重映射配置 解除调试端口如果想让调试端口作为普通的GPIO或者复用定时通道，需要先关闭调试复用端口也是用GPIO_PinRemapConfig函数这里的三个参数，就是用来解除调试端口的复用的 SWJ就是SWD和JTAG这两种调试方式 NoJTRST是接触JTRST引脚的复用，也就是PB4 JTAGDisable是解除JTAG，也就是PA15、PB3、PB4三个端口变回GPIO，上面PA13、PA14仍为SWD的调试端口 SWJ_Disable把SWD和JTAG的调试端口全部解除，此时不能使用STLINK下载程序了，只能使用串口下载 所以我们可以使用AFIO寄存器来重映射引脚 开启AFIO的时钟 选择重映射方式 解除 123456//开启时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);//重映射其他端口：如定时器或其他外设，才需要加这一句GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);//解除调试端口的代码：解除JTAG的调试端口 GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); PWM舵机 电机驱动需要5v供电，而面包板上只有3.3v，所以需要接到STLINK的5v供电口 代码 需要输出这样的波形 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;stm32f10x.h&quot; // Device header//大体上和上一个代码一样。只是改成了TIM2定时器void PWM_Init(void)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); TIM_InternalClockConfig(TIM2); TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 20000 - 1; //ARR TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; //PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure); TIM_OCInitTypeDef TIM_OCInitStructure; TIM_OCStructInit(&amp;TIM_OCInitStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = 0; //CCR TIM_OC2Init(TIM2, &amp;TIM_OCInitStructure); TIM_Cmd(TIM2, ENABLE);&#125;void PWM_SetCompare2(uint16_t Compare)&#123; TIM_SetCompare2(TIM2, Compare);&#125; 主函数👇 123456789101112131415161718192021222324252627282930313233#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot;#include &quot;OLED.h&quot;#include &quot;Servo.h&quot;#include &quot;Key.h&quot;uint8_t KeyNum;float Angle;int main(void)&#123; OLED_Init(); Servo_Init(); Key_Init(); OLED_ShowString(1, 1, &quot;Angle:&quot;); while (1) &#123; KeyNum = Key_GetNum(); if (KeyNum == 1) &#123; Angle += 30; if (Angle &gt; 180) &#123; Angle = 0; &#125; &#125; Servo_SetAngle(Angle); OLED_ShowNum(1, 7, Angle, 3); &#125;&#125; 可以使用同一个定时器输出不同通道的PWM，他们的频率是一致的， 因为使用的是同一个计数器，他们的占空比由各自CCR决定， 他们的相位，由于计数器的更新，所有的PWM同时跳变，所以他们的相位是同步的 封装函数舵机驱动&#96;servo 1234567891011121314#include &quot;stm32f10x.h&quot; // Device header#include &quot;PWM.h&quot;void Servo_Init(void)&#123; PWM_Init();&#125;void Servo_SetAngle(float Angle)&#123; PWM_SetCompare2(Angle / 180 * 2000 + 500); //此处为PWM对应的角度映射 //0°时是500 //180°时是2500&#125; PWM驱动直流电机 注意：前面所配置的时钟频率都是10kHZ 而直流电机在堵转的时候会发出类似蜂鸣器的声音，原因是定时器的频率太低了 所以在此历程中，我们将时钟频率提高到了20KHz，人耳就听不到了 123456789101112131415161718192021222324252627282930313233#include &quot;stm32f10x.h&quot; // Device header#include &quot;PWM.h&quot;void Motor_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //开启PA4、PA5 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); PWM_Init();&#125;void Motor_SetSpeed(int8_t Speed)&#123; if (Speed &gt;= 0) //设置正转 &#123; GPIO_SetBits(GPIOA, GPIO_Pin_4); GPIO_ResetBits(GPIOA, GPIO_Pin_5); PWM_SetCompare3(Speed); //此处传进去的是占空比 &#125; else //反转 &#123; GPIO_ResetBits(GPIOA, GPIO_Pin_4); GPIO_SetBits(GPIOA, GPIO_Pin_5); PWM_SetCompare3(-Speed); &#125;&#125;","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"OMV图像处理方法","slug":"02-Openmv图像处理方法","date":"2023-05-10T11:35:55.280Z","updated":"2023-05-10T13:59:41.800Z","comments":true,"path":"2023/05/10/02-Openmv图像处理方法/","link":"","permalink":"http://example.com/2023/05/10/02-Openmv%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"openmv文档官方学习文档[[01-图像处理入门]]感光元件sensor模块，用于设置感光元件的参数 1234567891011import sensor#引入感光元件的模块# 设置摄像头sensor.reset()#初始化感光元件sensor.set_pixformat(sensor.RGB565)#设置为彩色sensor.set_framesize(sensor.QVGA)#设置图像的大小sensor.skip_frames()#跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。# 一直拍照while(True): img = sensor.snapshot()#拍摄一张照片，img为一个image对象 初始化sensor.reset()初始化感光元件 设置彩色&#x2F;黑白sensor.set_pixforma()设置像素模式 设置彩色／黑白 sensor.set_pixformat() 设置像素模式。 sensor.GRAYSCALE: 灰度，每个像素8bit。 sensor.RGB565: 彩色，每个像素16bit。 设置图像大小 sensor.set_framesize() 设置图像的大小 sensor.QQCIF: 88x72 sensor.QCIF: 176x144 sensor.CIF: 352x288 sensor.QQSIF: 88x60 sensor.QSIF: 176x120 sensor.SIF: 352x240 sensor.QQQQVGA: 40x30 sensor.QQQVGA: 80x60 sensor.QQVGA: 160x120 sensor.QVGA: 320x240 sensor.VGA: 640x480 sensor.HQQQVGA: 80x40 sensor.HQQVGA: 160x80 sensor.HQVGA: 240x160 sensor.B64X32: 64x32 (用于帧差异 image.find_displacement()) sensor.B64X64: 64x64 用于帧差异 image.find_displacement()) sensor.B128X64: 128x64 (用于帧差异 image.find_displacement()) sensor.B128X128: 128x128 (用于帧差异 image.find_displacement()) 跳过一些帧 sensor.skip_frames(n&#x3D;10) 跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。 获取一张图像 sensor.snapshot() 拍摄一张照片，返回一个image对象。 自动增益／白平衡／曝光 sensor.set_auto_gain() 自动增益开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动增益。 sensor.set_auto_whitebal() 自动白平衡开启（True）或者关闭（False）。在使用颜色追踪时，需要关闭自动白平衡。 &#96;sensor.set_auto_exposure(enable[, exposure_us]) enable 打开（True）或关闭（False）自动曝光。默认打开。 如果 enable 为False， 则可以用 exposure_us 设置一个固定的曝光时间（以微秒为单位）。?怎么设置 设置窗口ROIsensor.set_windowing(roi)ROI：Region Of Interest，图像处理中的术语“感兴趣区”。就是在要处理的图像中提取出的要处理的区域。 12sensor.set_framesize(sensor.VGA) # 高分辨率sensor.set_windowing((640, 80)) #取中间的640*80区域 roi的格式是(x, y, w, h) ROI感兴趣的区域roi的格式是(x, y, w, h)的tupple(元组). x:ROI区域中左上角的x坐标 y:ROI区域中左上角的y坐标 w:ROI的宽度 h:ROI的高度 Statistics1image.get_statistics(roi=Auto) Statics函数1image.get_statistics([_thresholds_[, _invert=False_[, _roi_[, _bins_[, _l_bins_[, _a_bins_[, _b_bins_[, _difference_]]]]]]]]) 计算 roi 中每个颜色通道的平均值、中值、众值、标准偏差、最小值、最大值、下四分值和上四分值，并返回一个数据对象。 请参见 statistics 对象以获取更多信息。您也可以使用 image.get_stats 或 image.statistics 来调用这一方法。 如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。您还可以通过进入OpenMV IDE中的 工具 -&gt;机器视觉 -&gt;阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 您可以在需要获取图像中一个像素区域信息时使用这一方法。例如：若您想用帧差法来检测运动时， 您需要使用这一方法来确定图像颜色通道的变化，从而触发运动检测阈值。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。不支持压缩图像和bayer图像其中roi是目标区域。注意，这里的roi，bins之类的参数，一定要显式地标明，例如： 1img.get_statistics(roi=(0,0,10,20)) 如果是 img.get_statistics((0,0,10,20))，ROI不会起作用。 statistics.mean() 返回灰度的**平均数(0-255) (int)。你也可以通过statistics[0]获得。 statistics.median() 返回灰度的中位数。你也可以通过statistics[1]获得。 statistics.mode() 返回灰度的众数。你也可以通过statistics[2]获得。 statistics.stdev() 返回灰度的标准差。你也可以通过statistics[3]获得。 statistics.min() 返回灰度的最小值。你也可以通过statistics[4]获得。 statistics.max() 返回灰度的最大值。你也可以通过statistics[5]获得。 statistics.lq() 返回灰度的第一四分数。你也可以通过statistics[6]获得。 statistics.uq() 返回灰度的第三四分数。你也可以通过statistics[7]获得。 上面的是灰度的值，接下来的 l_mean，l_median，l_mode，l_stdev，l_min，l_max，l_lq，l_uq， a_mean，a_median，a_mode，a_stdev，a_min，a_max，a_lq，a_uq， b_mean，b_median，b_mode，b_stdev，b_min，b_max，b_lq，b_uq， 是LAB三个通道的平均数，中位数，众数，标准差，最小值，最大值，第一四分数，第三四分数。 举例 检测左上方的区域中的颜色值。 12345678910111213141516171819import sensor, image, time # 导入模块（库）sensor.reset() # 初始化摄像头sensor.set_pixformat(sensor.RGB565) # 格式为 RGB565. 固定格式sensor.set_framesize(sensor.QVGA) #设置帧大小压缩了画质sensor.skip_frames(10) # 跳过10帧，使新设置生效sensor.set_auto_whitebal(False) # 自动白平衡# 在颜色追踪的时候关闭自动白平衡ROI=(80,30,15,15) #设置ROI的感兴趣区，(x,y,x_width,y_heigth)while(True): img = sensor.snapshot() # 拍一张照片，然后返回这个照片 snapshot- statistics=img.get_statistics(roi=ROI) color_l=statistics.l_mode() # L是亮度 color_a=statistics.a_mode() # a是正数是红色，负数是绿色 color_b=statistics.b_mode() # b是正数是黄色，负数是蓝色 print(color_l,color_a,color_b) # 在串口打印 img.draw_rectangle(ROI) 结果： 终端 1234567891011121314151617181920212256 66 5156 66 5556 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5156 66 5556 66 5156 66 5156 66 5156 66 5156 66 51 设置翻转sensor.set_hmirror(True)水平方向翻转 sensor.set_vflip(True)垂直方向翻转","categories":[{"name":"Openmv学习","slug":"Openmv学习","permalink":"http://example.com/categories/Openmv%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Openmv","slug":"Openmv","permalink":"http://example.com/tags/Openmv/"}]},{"title":"图像处理入门","slug":"01-图像处理入门","date":"2023-05-09T15:25:15.081Z","updated":"2023-05-10T11:04:00.781Z","comments":true,"path":"2023/05/09/01-图像处理入门/","link":"","permalink":"http://example.com/2023/05/09/01-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/","excerpt":"","text":"[[23.5.9]]LAB亮度-对比度Lab颜色空间中，L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色，负端代表兰色。不像RGB和CMYK色彩空间，Lab颜色被设计来接近人类视觉。因此L分量可以调整亮度对，修改a和b分量的输出色阶来做精确的颜色平衡。 注意：在OpenMV的查找色块的算法中，运用的就是这个LAB模式！ 光源的选择如果你的机器是在工业上，或者24小时长时间运行的设备，保持一个稳定的光源是至关重要的，尤其在颜色算法中。亮度一变，整个颜色的值会变化的很大！ REPL和串口OpenMV的IDE自带一个串口助手，用于连接OpenMV，也可以连接其他的串口，比如Arduino，pyboard，esp8266。首先，断开OpenMV与IDE的连接，否则串口会冲突！打开OpenMV 中的 工具 → Open Terminal → New Terminal 在终端里输入 1print(&quot;hello OpenMV!&quot;) 会显示 1hello OpenMV! python 入门list列表Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示： 12classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]classmates 1[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 变量classmates就是一个list。用len()函数可以获得list元素的个数： 1len(classmates) 13 用索引来访问list中每一个位置的元素，记得索引是从0开始的： 12345678910 classmates[0]&#x27;Michael&#x27; classmates[1]&#x27;Bob&#x27; classmates[2]&#x27;Tracy&#x27; classmates[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： 12 classmates[-1]&#x27;Tracy&#x27; 以此类推，可以获取倒数第2个、倒数第3个： 12345678 classmates[-2]&#x27;Bob&#x27; classmates[-3]&#x27;Michael&#x27; classmates[-4]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 当然，倒数第4个就越界了。list是一个可变的有序表，所以，可以往list中追加元素到末尾： 12345678910111213141516171819202122 classmates.append(&#x27;Adam&#x27;) classmates [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]# 也可以把元素插入到指定的位置，比如索引号为1的位置： classmates.insert(1, &#x27;Jack&#x27;) classmates [&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]# 要删除list末尾的元素，用pop()方法： classmates.pop() &#x27;Adam&#x27; classmates [&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]# 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： classmates[1] = &#x27;Sarah&#x27; classmates [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]# list里面的元素的数据类型也可以不同，比如： L = [&#x27;Apple&#x27;, 123, True]# 如果一个list中一个元素也没有，就是一个空的list，它的长度为0： L = [] len(L) 0 tuple元组另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字： 1classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;) 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如： 123t = (1, 2)t(1, 2) 但是，要定义一个只有1个元素的tuple，如果你这么定义： 123t = (1)t1 定义的不是tuple，t是整型变量，变量t的值为1！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123 t = (1,) t(1,) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。 条件判断if语句的完整形式是： 12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 比如： 1234567age = 20if age &gt;= 6: print(&#x27;teenager&#x27;)elif age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;kid&#x27;) 循环Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来 123names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names: print(name) 执行这段代码，会依次打印names的每一个元素： 123MichaelBobTracy 所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： 123list(range(5))[0, 1, 2, 3, 4] range(101)就可以生成0-100的整数序列，计算如下： 1234sum = 0for x in range(101): sum = sum + xprint(sum) 第二种循环是while循环，比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 数据类型转换Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： 1234567891011121314&gt;&gt;&gt; int(&#x27;123&#x27;)123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float(&#x27;12.34&#x27;)12.34&gt;&gt;&gt; str(1.23)&#x27;1.23&#x27;&gt;&gt;&gt; str(100)&#x27;100&#x27;&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(&#x27;&#x27;)False 函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。我们先写一个计算x2的函数： 12def power(x): return x * x 对于power(x)函数，参数x就是一个位置参数。当我们调用power函数时，必须传入有且仅有的一个参数x： 12345&gt; &gt; &gt; power(5) &gt; &gt; &gt; 25 &gt; &gt; &gt; power(15) &gt; &gt; &gt; 225 现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干： 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 对于这个修改后的power(x, n)函数，可以计算任意n次方： 1234&gt; &gt; &gt; power(5, 2) &gt; &gt; &gt; 25 &gt; &gt; &gt; power(5, 3) &gt; &gt; &gt; 125 修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。 切片取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下： 1&gt; &gt; &gt; L = [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;, &#x27;Bob&#x27;, &#x27;Jack&#x27;] 取前3个元素，用一行代码就可以完成切片： L[0:3][‘Michael’, ‘Sarah’, ‘Tracy’] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： L[:3][‘Michael’, ‘Sarah’, ‘Tracy’] 也可以从索引1开始，取出2个元素出来： L[1:3][‘Sarah’, ‘Tracy’] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： ‘ABCDEFG’[:3]‘ABC’ 对象Python是面向对象编程的，比如一个LED灯 1234from pyb import LEDred_led = LED(1)red_led.on() LED是一个类，red_led就是一个对象，可以对这个对象进行操作，比如点亮on，关掉off，查看value。","categories":[{"name":"Openmv学习","slug":"Openmv学习","permalink":"http://example.com/categories/Openmv%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Openmv","slug":"Openmv","permalink":"http://example.com/tags/Openmv/"}]},{"title":"6-4TIM输出比较","slug":"04-定时器/6-4TIM输出比较","date":"2023-05-07T14:47:18.644Z","updated":"2023-05-12T11:25:27.419Z","comments":true,"path":"2023/05/07/04-定时器/6-4TIM输出比较/","link":"","permalink":"http://example.com/2023/05/07/04-%E5%AE%9A%E6%97%B6%E5%99%A8/6-4TIM%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83/","excerpt":"","text":"[[6-3定时器外部时钟]]输出比较简介 OC（Output Compare）输出比较 IC（Input Capture）输入捕获 CC（Capture&#x2F;Compare）输入捕获和输出比较的单元 输出比较可以通过比较CNT与CCR(捕获&#x2F;比较寄存器) 寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形 CCR是捕获和比较共用的，当使用输入捕获时，它就是捕获寄存器，当使用输出比较时，它就是比较寄存器 在输出比较中，电路会比较CNT和CCR的值，CNT自增，CCR给一个设定值，当CNT&gt;、&lt;或&#x3D;CCR时，这里输出对应就是置1，置0的一个电平不断跳变的PWM波形了 每个高级定时器和通用定时器都哟个有4个输出比较通道 高级定时器的前3个通道额外拥有死区生成和互补输出的功能 通用定时器和高级定时器都有4路输出比较的通道，可以同时输出四路PWM波形 4个通道有各自的CCR寄存器，但是它们是公用同一个CNT计数器的 输出比较模式 冻结：保持原状态，也可以理解成无效 如果正在输出PWM波，如果想暂停一会儿输出，就可以设置成这个模式 无效电平、电平反转、有效电平：是和关断、刹车这些功能配合表述的 电平反转可输出占空比为50%的波形 PWM模式1、2：可以用于输出频率和占空比都可调的PWM波形 一般都只使用向上计数 PWM 基本结构 CCR自设，CNT不断自增，同时CCR和CNT不断进行比较 当CNT&lt;CCR时，置高电平 当CNT&gt;CCR时，置低电平 当CNT计数满了之后，计数器清零，此时CNT&lt;CCR了，所以有置为高电平 所以PWM波形受CCR控制 舵机 舵机是一种根据输入PWM信号占空比，来控制输出角度的装置 舵机并不是一个单独的电机，内部是由直流电机驱动的，通过PWM输入到控制电路，给控制板一个指定的目标角度，然后电位器检测输出轴的当前角度，如果大于目标角度，电机就反转，小于目标角度，电机就正转，最终使得输出轴固定在指定角度 输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms 电机是大功率设备，最好能直接用电机电源驱动，如果单独供电，供电的负极要和STM32共地，然后正极接在5V供电引脚上 直流电机及其驱动由于直流电机没有自带驱动电路，所以我们需要外挂一个驱动电路来控制 直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作 TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并控制转速和方向 硬件电路 VM是驱动电压输入端，范围是4.5-10V，一般和电机额定电压保持一致 VCC是逻辑电平输入端，范围是2.7-5.5V，这个要和控制器的电压保持一致，比如STM32是3.3V的器件，就接3.3V AO1、AO2、BO1、BO2就是两路电机的输出，对应上端的PWMA,AIN2,AIN1这三个引脚控制下面A路的一个电机 最后还有STBY(Stand By)引脚，这个是待机控制引脚，如果接GND，芯片就不工作，处于待机状态，如果接逻辑电源VCC，芯片就正常工作","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"6-3 定时器外部时钟","slug":"04-定时器/6-3定时器外部时钟","date":"2023-05-07T14:47:18.640Z","updated":"2023-05-07T14:45:46.612Z","comments":true,"path":"2023/05/07/04-定时器/6-3定时器外部时钟/","link":"","permalink":"http://example.com/2023/05/07/04-%E5%AE%9A%E6%97%B6%E5%99%A8/6-3%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F/","excerpt":"","text":"[[6-2 定时器定时中断]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;stm32f10x.h&quot; // Device headervoid Timer_Init(void)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //不要忘记开GPIOA的时钟 GPIO_InitTypeDef GPIO_InitStructure;//GPIO_Mode可以看手册表，手册表推荐配置成浮空输入，但是浮空输入电平会乱跳，所以此处配置成上拉输入 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//不适用内部时钟，而选择外部ETR时钟//通过ETR引脚的外部时钟模式2配置 TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0x0F); //第二个参数是外部触发预分频器，不需要分频，所以是OFF//第三个参数是外部触发的极性 //第一个是反向，就是低电平或下降沿有效 //第二个是不反向，就是高点平或上升沿有效//第四个参数是外部触发滤波器，必须是0x00到0x0F之间的一个值 //如果传感器在使用的时候，遮挡一次CNT的值就胡乱增加，就可以在这里使用滤波器，来提高稳定性 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInitStructure.TIM_Period = 10 - 1; //我们这里不需要这么快的置，所以都改小点，这里自动重装值给10，从0记到9就行了，所以加到9后会自动清零。同时申请中断，Num++ TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1; //预分频给0也就是不要分频，如果有预分频，就是遮挡多几次才会+1 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure); TIM_ClearFlag(TIM2, TIM_FLAG_Update); TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(&amp;NVIC_InitStructure); TIM_Cmd(TIM2, ENABLE);&#125;uint16_t Timer_GetCounter(void)//封装实时查看计数器值的函数，这样比较规范&#123; return TIM_GetCounter(TIM2);&#125;/*void TIM2_IRQHandler(void)&#123; if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) &#123; TIM_ClearITPendingBit(TIM2, TIM_IT_Update); &#125;&#125;*/ 手册表 GPIO_Mode推荐配置浮空输入，但是不太喜欢，因为一旦悬空，电平就会跳个没完，所以配置成上拉输入，这也是可以的 那什么时候可以使用浮空输入：在外部输入信号功率很小的时候，因为内部的上拉电阻可能会影响到输入信号，这时可以使用浮空输入，防止影响外部输入的电平 CNT初始值为2或者为其他的，因为你插入的时候有一次（或者几次）上拉输入，所以有初值，复位就好了开个ETR滤波， TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0x09);","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"6-2 定时器定时中断","slug":"04-定时器/6-2 定时器定时中断","date":"2023-05-07T14:47:18.636Z","updated":"2023-05-07T14:45:29.185Z","comments":true,"path":"2023/05/07/04-定时器/6-2 定时器定时中断/","link":"","permalink":"http://example.com/2023/05/07/04-%E5%AE%9A%E6%97%B6%E5%99%A8/6-2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD/","excerpt":"","text":"[[6-1_TIM定时中断]]定时器中断新建的Timer.c &amp; Timer.h文件在System文件夹下 RCC开启时钟 选择时基单元的时钟源，对于定时中断，我们就选择内部时钟源 配置时基单元，包括预分频器、自动重装器、计数模式 配置输出中断控制，阴虚更新中断到NVIC 配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级 运行控制 整个模块配置完成后，我们还需要使能一下计数器，不然计数器不会运行 定时器中断函数，这样这个中断函数每隔一段事件就能自动执行一次了 库函数解析TIM_TimeBaseInit时基单元初始化，用来配置时基单元的TIM_Cmd用于使能计数器，对应时基单元的运行控制TIM_ITConfig用于使能中断输出信号 ，对应中断输出控制(config v.配置) 像这样的ITConfig后面还会经常遇到，就是&#x3D;&#x3D;使能外设的中断输出&#x3D;&#x3D; TIM_InternalClockConfig选择内部时钟，参数只有一个，选择之后连线就是这样TIM_ITRxExternalClockConfig选择ITRx其他定时器时钟，第一个参数TIMx选择要配置的定时器，第二个参数InputTrigggerSource选择要接入哪个其他定时器，调用后连接变成这样TIM_TIxExternalClockConfig选择TIx捕获通道的时钟，第二个参数TIxExternalCLKSource选择TIx具体的某个引脚，ICPolarity和ICFilter，输入的极性和滤波器，调用后这样连接TIM_ETRClockMode1Config选择ETR通过外部时钟模式1输入的时钟，参数ExtTRGPrescaler外部触发预分频器(scalar n.标量)TIM_ETRConfig单独用来配置ETR引脚的预分频器、极性、滤波器等这些参数 时钟源的选择用这六个函数 时基单元，用TimeBaseInit函数 中断输出控制，用ITConfig函数 NVIC，用NVIC_Init函数 运行控制，用TIM_Cmd函数 TIM_PrescalarConfig，用于单独写预分频值 TIM_CounterModeConfig，用于改变计数器的计数模式 TIM_ARRPreloadConfig，自动重装器预装功能配置 TIM_SetCounter，给计数器写入一个值 TIM_SetAutoreload，给自动重装器写入一个值 TIM_GetCounter，获取当前计数器的值，返回值就是当前计数器的值 TIM_GetPrescalar，获取当前预分频器的值 timer.c文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &quot;stm32f10x.h&quot; // Device headerextern uint16_t Num; //告诉编译器，现在有Num这个变量，在别的文件中定义了，至于在哪自己去找//此处并没有定义新的变量，操作的仍然是main.c文件中的Num//当然也可以让中断函数放到main函数中，这样这个声明就不需要了void Timer_Init(void)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); TIM_InternalClockConfig(TIM2); TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //指定时钟分频，选择1分频 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //选择向上计数 TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; //period——ARR自动重装器的值 TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; //prescaler——PSC预分频器的值 //通过设置PSC和ARR的取值，来设定计时的长短 //72Mhz/7200=10k，10k的时间计10000个数，刚好就是1s，有一位是留给进位的 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //repetitioncounter——重复计数器的值，但是只有高级计数器才有，我们直接置零便可 //如果需要设置计数器的值，可以用setcounter和getcounter TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure); TIM_ClearFlag(TIM2, TIM_FLAG_Update); //手动清除标志位，避免刚初始化晚就进中断的问题。ChatGPT说TIM_ClearITFlag()函数只会清除中断相关标志位，因此涉及到中断标志位的清除推荐使用这个避免清除了其他标志位造成出错 TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); //ITupdate，更新参数，使能中断 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //选择分组2 NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; //中断通道 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//上面两个是抢占优先级和响应优先级 NVIC_Init(&amp;NVIC_InitStructure); TIM_Cmd(TIM2, ENABLE); //启动定时器，产生更新就会触发中断&#125;/* 当定时器产生更新时，这个函数就会被调用void TIM2_IRQHandler(void)&#123; if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) //检查标志位 &#123; TIM_ClearITPendingBit(TIM2, TIM_IT_Update); //最后清除标志位 &#125;&#125;*/ 定时器外部时钟","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"6-1 TIM定时器中断","slug":"04-定时器/6-1_TIM定时中断","date":"2023-05-07T14:47:18.634Z","updated":"2023-05-07T14:45:14.273Z","comments":true,"path":"2023/05/07/04-定时器/6-1_TIM定时中断/","link":"","permalink":"http://example.com/2023/05/07/04-%E5%AE%9A%E6%97%B6%E5%99%A8/6-1_TIM%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD/","excerpt":"","text":"[[05_3 旋转编码器]]简介TIM定时器 定时器可以对输入的时钟进行&#x3D;&#x3D;计数&#x3D;&#x3D;，并在计数值达到设定值时&#x3D;&#x3D;触发中断 16计数器、预分频器、自动重装器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时 计数器：用于执行计数定时的寄存器，每来一个时钟，计数器+1 预分频器：可以对计数器的时钟进行分频，让计数更灵活 自动重装寄存器：计数的目标值， 这些时基单元都是16位的，72M&#x2F;65535&#x2F;65535再取倒数&#x3D;59.65s。如果这个时间还不够长，STM32定时器支持级联的模式，这样时间就是59.65s×65535×65535&#x3D;8000多年 定时器不仅具备基本的定时器中断功能，而且还包括内外时钟源旋转，输入捕获，输出比较，编码器接口，主从触发器等多种功能 定时器这个基本模块是很通用的，很多模块电路都能用到 根据复杂度和应用场景分为&#x3D;&#x3D;高级定时器，通用定时器，基本定时器&#x3D;&#x3D; 类型 编号 总线 功能 高级定时器 TIM1、TIM8 APB2 拥有通用定时器的全部功能，并且&#x3D;&#x3D;额外具有重复计数、死区生成、互补输出、刹车输入&#x3D;&#x3D;等功能 通用定时器 TIM1、TIM3、TIM4、TIM5 APB1 拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能 基本定时器 TIM6、TIM7 APB1 拥有定时器中断、主模式触发ADC的功能 STM32F103CT定时器资源：TIM1、TIM2、TIM4、TIM4（没有基本定时器） 基本定时器 时钟源仅能选择72Mhz，然后通过预分频进行数值加减 基准时钟-&gt;预分频器-&gt;计数器自增并与自动重装载寄存器比较-&gt;达到自动重装载寄存器的值输出信号（下降沿是触发中断、下降沿是触发事件） 主模式触发DAC：能够让内部硬件在不受程序的控制下实现自动运行，如果能使用好，将在某些情景下极大减轻CPU的负担 使用DAC时可能需要DAC每隔一段时间输出一个波形，让他输出下一个电压点， 如果是正常的思路，是先设置一个定时器产生中断，每隔一段时间在中断程序中调用代码手动触发一次DAC转化，然后DAC输出 虽然这样也没问题，但是会使得主程序处于频繁被中断的状态，影响主程序的运行和其他中断的响应 所以使用主模式，可以将定时器更新的事件映射到触发输出TRGO（Trigger Out）的位置，然后TRGO直接接到DAC的触发转换引脚上 这样，定时器的更新就不需要通过中断来触发DAC转换了 仅需要把更新事件通过主模式映射到TRGO，然后TRGO就会直接去触发DAC了&#x3D;&#x3D;整个过程不需要软件的参与，实现了硬件的自动化，这就是主模式的作用&#x3D;&#x3D; 通用定时器 通用定时器支持 向上计数、 向下计数、 中央对齐（向上计数，到自动重装载值后触发一次中断，然后再向下计数，到自动重装载值后触发一次中断，如此往复 不仅可以选择72Mhz，还能选择外部时钟 外部时钟就是来自TIMx_ETR 引脚上的外部时钟，然后配置一下内部的&#x3D;&#x3D;极性选择、边沿检测和预分频电路，再配置一下输入滤波电路&#x3D;&#x3D;，对外部时钟进行一定的整形 ITR信号，这一部分信号是来自其他定时器，主模式输出TRGO可以通向其他定时器，解到了其他定时器ITR引脚上，ITR0-ITR3分别来自其他4个定时器的TRGO输出，通过这一路我们可以实现定时器级联的功能 高级定时器增加了重复计数计数器，可以实现每隔几个计数周期才发生一次更新事件和更新中断，相当于对输出信号又进行了一次分频 定时中断基本结构 预分频器时序 CNT_EN 预分频器使能，0关闭，1开启 CK_CNT 计数器时钟 后面的主要是缓冲的功能，当TIMx_PSC写入新数值时，预分频计数器仍会保持原来的分频进行计数，直到下一次计数时，才会是新的预分频 计数器时序 注意*：当逻辑图上的器件存在影子的时候，就是说明其有影子寄存器，也就是缓冲器，这个缓冲器是用还是不用，是可以自己设置的 所以影子寄存器的目的是为了&#x3D;&#x3D;同步&#x3D;&#x3D;，让值的变化和更新事件同步发生，防止在运行途中更改造成错误 无论是高级定时器、通用定时器、基本定时器，内部的基准时钟都是72Mhz [[6-2 定时器定时中断]]","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"05_3 旋转编码器","slug":"03-中断/05_3 旋转编码器","date":"2023-05-07T14:47:18.609Z","updated":"2023-05-07T14:44:10.120Z","comments":true,"path":"2023/05/07/03-中断/05_3 旋转编码器/","link":"","permalink":"http://example.com/2023/05/07/03-%E4%B8%AD%E6%96%AD/05_3%20%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8/","excerpt":"","text":"[[05_2 红外对射式传感器计次]]细节问题由于旋转编码器会存在两条相位差为90°波形图，所以会在中断触发上存在问题![[5-1旋转编码器#^2ad2e9]] 最终的解决办法是： 在a波形是低电平的时候，触发中断，同时b电平是下降沿的时候判断为是正转 反转同理：a是下降沿，b是低电平 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687void Encoder_Init(void)&#123; //这里是直接复制红外计数器的工程 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1; //这里需要改成pin1和pin0 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0); //来源也要改 GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1); EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(&amp;EXTI_InitStructure); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //此处需要对两个中断设置不同的优先级 NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //注意这里要改成EXTI0，而下面是改成EXTI1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn; //这里改成EXTI1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //同时把这个优先级改低一些，改成2 NVIC_Init(&amp;NVIC_InitStructure);&#125; //定义一个带符号的变量int16_t Encoder_Count; //注意此处的中断函数有两个固定的名称void EXTI0_IRQHandler(void)&#123; if (EXTI_GetITStatus(EXTI_Line0) == SET) //象征性地检查一下标志位是否已经触发，因为这个函数只有EXTI0是可以触发的 &#123; /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/ if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0) //判断一下此时另外一个接口是否出现了低电平，如果是那么就认为是正转 &#123; if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0) &#123; Encoder_Count --; &#125; &#125; EXTI_ClearITPendingBit(EXTI_Line0); &#125;&#125;void EXTI1_IRQHandler(void)&#123; if (EXTI_GetITStatus(EXTI_Line1) == SET) &#123; /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/ if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0) &#123; if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0) &#123; Encoder_Count ++; &#125; &#125; EXTI_ClearITPendingBit(EXTI_Line1); &#125;&#125; //最后需要一个函数返回变化的值，因为我们希望实现转两边的效果？其实我也不是很懂为什么要清零int16_t Encoder_Get(void)&#123; int16_t Temp; Temp = Encoder_Count; Encoder_Count = 0; //由于即需要返回值，又需要清零，所以临时增加了一个变量用于存放 return Temp;&#125; 主函数int16_t Num; int main(void) &#123; OLED_Init(); Encoder_Init(); OLED_ShowString(1, 1, &quot;Num:&quot;); while (1) &#123; Num += Encoder_Get(); OLED_ShowSignedNum(1, 5, Num, 5); &#125; &#125;","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"05_2 红外对射式传感器计次","slug":"03-中断/05_2 红外对射式传感器计次","date":"2023-05-07T14:47:18.604Z","updated":"2023-05-07T14:43:46.869Z","comments":true,"path":"2023/05/07/03-中断/05_2 红外对射式传感器计次/","link":"","permalink":"http://example.com/2023/05/07/03-%E4%B8%AD%E6%96%AD/05_2%20%E7%BA%A2%E5%A4%96%E5%AF%B9%E5%B0%84%E5%BC%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1/","excerpt":"","text":"[[04_2_keil调试工具]]红外对射式传感器接线图 1.配置中断配置中断的流程从GPIO一直到NVIC这一路中出现的外设模块都配置好 配置RCC，将涉及到的外设时钟都打开 配置GPIO，选择端口为输入模式 配置AFIO，选择这一路的GPIO，连接到后面的EXTI 配置EXTI，选择边沿触发方式（上升下降双边）、触发响应方式（中断响应或事件响应） 配置NVIC，外部中断信号就能进入CPU 注意 EXTI和NVIC（使用内核的时钟）这两个外设时钟是一直开启着的 中断函数的名字是固定的，名字可以参考启动文件，这里的函数名都是固定的 中断函数都是无参无返回值的，void func(void) 完成中断后记得要清除标记位，最下面那行，然后在这两个红框之间可以放我们想要的函数 AFIO库函数 AFIO的库函数在GPIO.h文件夹中 GPIO_PinRemapConfig用于进行引脚重映射，第一个参数选择重映射的方式，第二个参数是新的状态 GPIO_WXTILineConfig可以配置AFIO的数据选择器，来选择我们想要的中断引脚用这个 GPIO_ETH_MediaInterfaceConfig这个是和以太网有关的，我们这个芯片没有以太网，暂时用不到 EXTI库函数 在exti.h文件夹下 EXTI_DeInit清除EXTI配置，恢复成上电默认的状态 EXTI_Init初始化EXTI EXTI_GenerateSWInterrupt用于软件触发外部中断，调用这个函数，参数给一个指定的中断线，就能软件触发一次这个外部中断 剩下的是库函数的模板函数，在外设运行中，会产生一些状态标志位，这些标志位会放到&#x3D;&#x3D;状态寄存器&#x3D;&#x3D;，当我们需要查看这些标志位的时候，就可以用到这四个函数 在&#x3D;&#x3D;主程序&#x3D;&#x3D;中查看标志位，GetFlagStatus可以获取指定的标志位是否被置一，ClearFlag可以对置一的标志位进行清除 在&#x3D;&#x3D;中断中&#x3D;&#x3D;需要查看标志位可以用下面量函数，GetITStatus获取中断标志位是否被置一，ClearIPendingBit清楚中断挂起标志位 NVIC库函数由于NVIC是内核外设，所以库函数被分配到杂项misc.c文件中 NVIC_PriorityGroupConfig用于&#x3D;&#x3D;中断分组&#x3D;&#x3D;，参数是中断分组的方式 pre-emption priority 先占优先级-抢占优先级 subpriority 从占优先级- 响应优先级 NVIC_SetVectorTable设置中断向量表 NVIC_SystemLPConfig系统低功耗配置，一般物联网会有要求 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int16_t CountSensor_Count; //在此处定义一个全局变量供给在中断中使用void CountSensor_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //开启GPIO的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //开启AFIO的时钟 GPIO_InitTypeDef GPIO_InitStructure; //初始化GPIO GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14); //配置AFIO EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line14; //指定需要跳转的中断线 EXTI_InitStructure.EXTI_LineCmd = ENABLE; //指定中断线的新状态 EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //指定选择的中断线的模式， EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //选择触发模式 EXTI_Init(&amp;EXTI_InitStructure); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //NVIC是核内外设，被分配到，misc.c文件中 NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn; //指定中断通道是开启或关闭，指定开启EXTI15~10开启 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //指定中断通道是使能还是失能 //我们选择的分组是组2，所以对应优先级的取值范围是0~3 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; //指定抢占优先级 但是因为这里只有一个中断，就随便取的值 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; //指定响应优先级 NVIC_Init(&amp;NVIC_InitStructure);&#125;uint16_t CountSensor_Get(void) //此处直接返回&#123; return CountSensor_Count;&#125;void EXTI15_10_IRQHandler(void)&#123; if (EXTI_GetITStatus(EXTI_Line14) == SET) &#123; /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/ if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0) &#123; CountSensor_Count ++; &#125; EXTI_ClearITPendingBit(EXTI_Line14); &#125;&#125; 不同的触发模式对现象的影响 选择上升沿触发 程序会在挡片拿走的时候计次 选择下降沿触发 程序会在挡片落下的时候计次 选择双边沿触发 程序会在挡片落下和拿走的时候都计次，也就是变化两次","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"05_1 EXTI外部中断","slug":"03-中断/05_1 EXTI外部中断","date":"2023-05-07T14:47:18.602Z","updated":"2023-05-07T14:43:17.343Z","comments":true,"path":"2023/05/07/03-中断/05_1 EXTI外部中断/","link":"","permalink":"http://example.com/2023/05/07/03-%E4%B8%AD%E6%96%AD/05_1%20EXTI%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/","excerpt":"","text":"[[04_2_keil调试工具]]中断系统 中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而取处理中断程序，处理完成后又返回原来被暂停的位置继续运行 中断优先级：当有多个中断源同时申请中断,CPU 会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源 中断嵌套：当一个中断程序正在运行时，又有新的更高的优先级的中断源申请中断，CPU再次暂停当前的中断程序，转而取处理新的中断程序，处理完后再依次进行返回 EXTI简介当中断来临时，由硬件自动调用整个函数 整体结构图 AFIO中断引脚选择：可以选择3个GPIO的16个引脚里选择其中一个连接到后面的EXTI通道里，所以相同的PIN不能触发中断 后面会经过EXTI边沿检测及控制，讲信号分成两部分：NVIC和其他外设 注意：外部中断的95，和1510，分配到同一个通道里，也就是外部中断的95会触发同一个中断函数，1510同理 AFIOAFIO复用IO口 AFIO 主要用于引脚复用功能的选择和重定义 在STM32中，AFIO主要完成 复用功能引脚重映射 中断引脚选择 触发方式： &#x3D;&#x3D;上升沿&#x3D;&#x3D;：电平从低电平变到高电平的瞬间触发中断 &#x3D;&#x3D;下降沿&#x3D;&#x3D;：与上面相反 &#x3D;&#x3D;双边沿&#x3D;&#x3D;：上升沿和下降沿都可以触发中断 软件触发：不需要电平变化，程序一句话就可以触发中断 响应方式中断响应：是正常的流程，引脚电平触发中断事件触发：外部中断信号就不会通向CPU了，而是&#x3D;&#x3D;通向其他外设，用来触发其他外设的操作&#x3D;&#x3D;，属于外设之间的联合工作 比如触发ADC转化、触发DMA等 STM32中断68个可屏蔽中断通道、包含&#x3D;&#x3D;EXTI外部中断、TIM定时器、ADC模数转换器、USART串口、SPI通信、I2C通信、RTC实时时钟&#x3D;&#x3D;等多个外设（具体数量以对应型号的数据手册为准） 模块多、且几乎所有外设都可以申请中断 使用NVIC同一管理中断、每个中断通道都拥有16个可编程的优先级，可对优先级进行分组看门狗WWDG：如果程序卡死了，没有及时喂狗，窗口看门狗就会申请中断，让程序跳转到窗口看门够的中断程序中，我们可以在中断程序里进行一些错误检查，看看出现什么问题了电源电压进检测PVD：如果供电电压不足，PVD电路就会申请中断，在中断中就可以知道是电池没电供电不足，要赶紧保存一下重要数据 总而言之，当外设电路检测到有什么异常或者事件，需要提示一下CPU的时候，它就可以申请中断，让程序跳到对应的中断函数里运行一次，用来处理这个异常或事件 NVIC基本结构在STM32中用来统一分配中断优先级和管理中断，它是一个内核外设，是CPU小助手，类似优先编码器 NVIC的优先分组 类似插队的形式叫做响应优先级，即处理完前一个程序后，插队进去优先处理 可以直接打断当前叫做抢占优先级，类似前面所讲的中断嵌套 分组方式是我们自己选择，选好分组后，我们在配置优先级的时候，就要注意抢占优先级和响应优先级的取值范围了","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"04_2 keil调试工具","slug":"02-调参工具/04_2_keil调试工具","date":"2023-05-07T14:47:18.581Z","updated":"2023-05-07T14:42:57.433Z","comments":true,"path":"2023/05/07/02-调参工具/04_2_keil调试工具/","link":"","permalink":"http://example.com/2023/05/07/02-%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7/04_2_keil%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","excerpt":"","text":"[[04_1_OLED调试工具]] Keil调试 Debug设置 设置界面 左边是仿真模拟器调试，右边是硬件调试，我们选择硬件调试 选择右上角放大镜，进入调试模式 调试界面介绍 从左到右依次是：&#x3D;&#x3D;单步运行&#x3D;&#x3D;、&#x3D;&#x3D;跳过当前单步运行&#x3D;&#x3D;、&#x3D;&#x3D;跳出当前函数单步运行&#x3D;&#x3D;、&#x3D;&#x3D;调到光标指定行单步运行&#x3D;&#x3D; 从左到右依次是： 命令窗口、 反汇编窗口、 符号窗口：可实时查看程序中所有变量的值，同时可以将其右键添加到Watch1窗口方便查看 剩下的是串口显示，逻辑分析仪等等 外设菜单栏-&gt;系统资源查看-&gt;可实时查看所有外设寄存器 标记函数 选择需要标记的行 然后按上面的小旗子，再次点击清除标签、 点击第二个按钮，就是跳转到上一个标签的位置 点击第三个按钮，就是跳转到下一个标签的位置 点击第四个按钮，就是清除所有标签 [[05_1 EXTI外部中断]]","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"04_1 OLED测试工具","slug":"02-调参工具/04_1_OLED调试工具","date":"2023-05-07T14:47:18.577Z","updated":"2023-05-07T14:40:26.449Z","comments":true,"path":"2023/05/07/02-调参工具/04_1_OLED调试工具/","link":"","permalink":"http://example.com/2023/05/07/02-%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7/04_1_OLED%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","excerpt":"","text":"[[03_2 GPIO输入]]OLED简介 OLED：有机发光二极管 OLED显示屏：功耗低，响应速度快，宽视角（因为oled是自发光，在任何角度看都是清晰的，相反lcd只能正面看），轻薄柔韧 供电：3~5.5V。通信协议：I2C&#x2F;SPI，分辨率：128*64 调试方式 串口调试：通过串口通信，将调试信息发送到电脑端，电脑使用串口助手显示调试信息 显示屏调试：直接将显示器连接到单片机，将调试信息打印在显示屏上 Keil调试模式：借助keil软件的调试模式，可以使用&#x3D;&#x3D;单步运行&#x3D;&#x3D;&#x3D;，&#x3D;&#x3D;设置断点&#x3D;&#x3D;、&#x3D;&#x3D;查看寄存器及变量&#x3D;&#x3D;等功能 硬件电路 SCL和SDA是I2C的通信引脚，本课程使用的是GPIO模拟的I2C通信 OLED驱动函数 与51单片机一样 OLED 是不自带字库的，需要在OLED_Font.h字库中自行设置，可以配合取字模软件使用OLED屏幕的位置这样设置 注意OLED_ShowNum显示无符号数字的时候，设置的位数多了会在前面高位自动补0，设置的 位数少了会将高位丢弃OLED_ShowSignedNum是显示有符号数字，正数在前面补“+”，负数在前面补“-”OLED_Clear清屏指令","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"03_2 GPIO输入","slug":"01-GPIO基本用法/03_2 GPIO输入","date":"2023-05-07T14:47:18.558Z","updated":"2023-05-07T14:39:47.301Z","comments":true,"path":"2023/05/07/01-GPIO基本用法/03_2 GPIO输入/","link":"","permalink":"http://example.com/2023/05/07/01-GPIO%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/03_2%20GPIO%E8%BE%93%E5%85%A5/","excerpt":"","text":"[[03_1 LED输出]]按键介绍 按键:常见的输入设备，按下导通，松手断开 按键会存在抖动 传感器模块介绍 传感器：光敏电阻&#x2F;热敏电阻&#x2F;红外接收管 传感器的元件的电阻会随着外界的模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出 注意这其中一个传感器，N1为传感器电阻本身，上面的R1是用来和传感器电阻进行分压，旁边的电容作用是用来滤波（用来保证电路为稳定，在分析的时候可以忽略），然后可以用分压定理来分析一下传感器电阻的阻值变化对电压的影响 当N1阻值变小时，下拉作用会增强，中间AO端的电压会拉低，极端情况下，AO输出被完全下拉，输出为0 当N1阻值变大，下拉作用被减弱，中间的引脚由于R1的上拉作用，电压就会升高，极端情况下，N1阻值无穷大，相当于断路，输出电压被R1拉高至VCC 二值化模块（LM393）LM393是一个电压比较器芯片中间红框是有两个独立的电压比较电路，其实这个电压比较器就是两个运算放大器[[51单片机的AD&#x2F;DA]] 当同相输入端的电压大于反相输入端的电压时，输出会瞬间升为最大值VCC 反之，当同相输入端的电压小于反相输入端的电压时，输出会瞬间降低为最小值GND 这样就能对模拟电路进行二值化 红外传感器对于红外传感器，N1就是一个红外接收管，对应会多一个点亮红外发射管的电路， 发射管发射红外光， 接收管接收红外光， 电位器直接换成了两个电阻进行分压，这样数字输出就是固定阈值的二值化 硬件电路按键的硬件电路可以分为上接和下接模式，一般选择下接，和LED接法类似，是电路设计的习惯和规范 一、直接与GND相连随便选取一个GPIO口，通过K1接地，当按键按下时，PA0被直接下拉到GND，此时读取PA0口的电压就是低电平当按键松手时，PA0被悬空，此时悬空会导致引脚电压不确定，所以在这种接法下，必须要求PA0是上拉输入模式，否则会出现引脚电压不确定的错误现象如果PA0是上拉输入模式，引脚再悬空，PA0就是高电平，所以这种模式下，按下为低电平，松开就是高电平 二、外部接上拉电阻如果外部没有接上拉电阻，就必须要开启上拉输入模式。外接了上拉电阻就可以选择浮空输入 当按键按下时，引脚直接接到GND，此时PA0的引脚可以配置为浮空输入或者上拉输入 因为由内外电路双重控制，此时的高电平会更强一些，对应的高电平会更加稳定 但是当引脚强行拉低时，损耗也会大一些 三、上接接法单片机一般没有下拉模式，且下拉模式不强，不建议学 按键控制LED C 语言数据类型 注意： C语言中int是16位的，但是在stm32中int是32位，short是16位，long也是32位的 注意stdint关键字，是C语言提供的有stdint.h头文件给前面的重命名，后面的_t的意思是typedefine 重命名，但是其实只是换一个名字而已 封装库函数新建文件夹hardware用于存放&#x3D;&#x3D;硬件驱动&#x3D;&#x3D;，比如led直接新建.c/.h的文件夹 led.c的文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &quot;stm32f10x.h&quot;void LED_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //开启端口时钟 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //选择推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2; //选择pin1和pin2 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //选择时钟速度 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2); //setbit，高电平，led不点亮，这样能默认led是熄灭的状态&#125;void LED1_ON(void) //然后就是led1开&#123; GPIO_ResetBits(GPIOA, GPIO_Pin_1);&#125;void LED1_OFF(void) //led1关&#123; GPIO_SetBits(GPIOA, GPIO_Pin_1);&#125;void LED1_Turn(void) //led取反&#123; if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0) &#123; GPIO_SetBits(GPIOA, GPIO_Pin_1); &#125; else &#123; GPIO_ResetBits(GPIOA, GPIO_Pin_1); &#125;&#125;void LED2_ON(void) 下面同理&#123; GPIO_ResetBits(GPIOA, GPIO_Pin_2);&#125;void LED2_OFF(void)&#123; GPIO_SetBits(GPIOA, GPIO_Pin_2);&#125;void LED2_Turn(void)&#123; if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0) &#123; GPIO_SetBits(GPIOA, GPIO_Pin_2); &#125; else &#123; GPIO_ResetBits(GPIOA, GPIO_Pin_2); &#125;&#125; 主函数123456789101112#ifndef __LED_H#define __LED_Hvoid LED_Init(void);void LED1_ON(void);void LED1_OFF(void);void LED1_Turn(void);void LED2_ON(void);void LED2_OFF(void);void LED2_Turn(void);#endif 按键封装 输入函数介绍 GPIO_ReadInputDataBit;此函数用于&#x3D;&#x3D;读取输入寄存器某一个端口的输入值&#x3D;&#x3D; 返回值是高低电平 GPIO_ReadInputData 相比较上一个函数少了bit，是用来读取整个&#x3D;&#x3D;输入数据寄存器&#x3D;&#x3D; 返回值是uint16_t ，是一个16位的数据，每一位代表一个端口值 输出函数介绍 GPIO_ReadOutputDataBit，用于读取输出寄存器的某一位 原则上来说不是用来读取端口的输入数据，一般用于输出模式，来看自己输出的是什么 GPIO_ReadOutputData，用于读取整个输出寄存器 12345678910111213141516171819202122232425262728293031323334353637#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot;void Key_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //注意按键在gpioB的位置 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //input 上拉模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11; //我们的按键接在了Pin1 &amp; Pin11 上 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //在输入模式下这个速度没有实际用处 GPIO_Init(GPIOB, &amp;GPIO_InitStructure);&#125;uint8_t Key_GetNum(void) //uint8_t = unsigned char &#123; uint8_t KeyNum = 0; //先初始一个值 //接下来就是寻找读取gpio端口值的函数 if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0) //如果pin1按下 &#123; Delay_ms(20); //延时消抖 while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0); //如果不松手就一直死循环 Delay_ms(20); //松手消抖 KeyNum = 1; //赋值 &#125; if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0) //pin11同理 &#123; Delay_ms(20); while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0); Delay_ms(20); KeyNum = 2; &#125; return KeyNum; //最后返回按键按下的键值&#125; 光敏传感器控制蜂鸣器光敏传感器12345678910111213141516void LightSensor_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //简简单单的初始化 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //上拉输入模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure);&#125;uint8_t LightSensor_Get(void) &#123; return GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13); //直接返回光敏电阻的读取值&#125; 蜂鸣器1234567891011121314151617181920212223242526272829303132333435void Buzzer_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOB, GPIO_Pin_12);&#125;void Buzzer_ON(void)&#123; GPIO_ResetBits(GPIOB, GPIO_Pin_12);&#125;void Buzzer_OFF(void)&#123; GPIO_SetBits(GPIOB, GPIO_Pin_12);&#125;void Buzzer_Turn(void)&#123; if (GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_12) == 0) &#123; GPIO_SetBits(GPIOB, GPIO_Pin_12); &#125; else &#123; GPIO_ResetBits(GPIOB, GPIO_Pin_12); &#125;&#125; [[04_1_OLED调试工具]]","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"03_1 LED输出","slug":"01-GPIO基本用法/03_1 LED输出","date":"2023-05-07T14:47:18.551Z","updated":"2023-05-07T14:39:57.037Z","comments":true,"path":"2023/05/07/01-GPIO基本用法/03_1 LED输出/","link":"","permalink":"http://example.com/2023/05/07/01-GPIO%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/03_1%20LED%E8%BE%93%E5%87%BA/","excerpt":"","text":"[[02_GPIO介绍]]示意图 注意：keilkill.bat程序可以删掉中间文件，这样体积就可以大大减小回顾操作顺序： 使用RCC开启GPIO的时钟 使用GPIO_Init初始化GPIO 使用输出或者输入的函数控制GPIO RCC的常用函数GPIO_DeInit初始化GPIO，调用这个函数所指定的GPIO外设会被复位GPIO_AFIODeInit可以复位AFIO外设GPIO_Init用结构体的参数来初始化GPIO口，需要先定义一个结构体变量，再给结构体赋值，最后再调用这个函数，这个函数就会自动读取结构体的值，然后自动把外设的各个参数配置好GPIO_StructInit可以把结构体变量赋一个默认值接下来是GPIO的读取函数然后是GPIO的写入函数 12345678910111213141516171819202122232425262728293031#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot; //delay函数直接拿来用就行，不需要问为什么int main(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //RCC使能 GPIO_InitTypeDef GPIO_InitStructure; //GPIO的结构体初始化 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //定义其中的结构体变量 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //然后引用GPIO初始化 while (1) &#123; GPIO_ResetBits(GPIOA, GPIO_Pin_0); //分别是3种不同的输入方式 Delay_ms(500); //注意这里是Bits，说明这个函数的参数可以是PIN的各种组合 GPIO_SetBits(GPIOA, GPIO_Pin_0); //这种是通过向GPIOA一整排set和reset来控制 Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET); //这个是通过向具体的GPIOA中的A0写数据来控制 Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET); Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0); //其中的BitAction是在库函数中的声明，是枚举类型，强制类型转化便可以正常输出 Delay_ms(500); GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1); Delay_ms(500); &#125;&#125; GPIO的8种输入模式 AIN（Analog IN)：模拟输入 IN_FLOATING：浮空输入 IPD（In Pull Down）是下拉输入 IPU（In Pull Up）是上拉输入 Out_OD：开漏输出 开漏输出的高电平相当于高阻态，没有输出能力，低电平有驱动能力 Out_OO：推挽输出高低电平均有驱动能力，所以一般的输出用推挽输出就可以了，但有一个问题是输出口不能串联 AF_OD（Atl Open Drain）：复用开漏 AF_PP（Atl Push Pull）：复用推挽 System文件夹是用来存放系统的资源：比方说Delay函数 LED闪烁 接线图 12345678910111213141516171819202122232425262728293031323334#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot;int main(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //此处也是需要开启GPIOA的使能 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All; //直接使用GPIO_ALL 来开启全部端口 GPIO_InitStructure.GPIO_Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4| //可以使用或|来进行多位的赋值 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); while (1) &#123; GPIO_Write(GPIOA, ~0x0001); //0000 0000 0000 0001 因为是低电平点亮，所以要取反 Delay_ms(100); GPIO_Write(GPIOA, ~0x0002); //0000 0000 0000 0010 Delay_ms(100); GPIO_Write(GPIOA, ~0x0004); //0000 0000 0000 0100 Delay_ms(100); GPIO_Write(GPIOA, ~0x0008); //0000 0000 0000 1000 Delay_ms(100); GPIO_Write(GPIOA, ~0x0010); //0000 0000 0001 0000 Delay_ms(100); GPIO_Write(GPIOA, ~0x0020); //0000 0000 0010 0000 Delay_ms(100); GPIO_Write(GPIOA, ~0x0040); //0000 0000 0100 0000 Delay_ms(100); GPIO_Write(GPIOA, ~0x0080); //0000 0000 1000 0000 Delay_ms(100); &#125;&#125; 蜂鸣器 注意不要是要使用A15，B3，B4，这三个端口默认是JTAG的调试端口，如果想正常使用还需要外加配置 12345678910111213141516171819202122#include &quot;stm32f10x.h&quot; // Device header#include &quot;Delay.h&quot;int main(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //此处也是需要开启GPIOB的使能，蜂鸣器使用的是B12输出 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; //直接使用GPIO_ALL 来开启全部端口 //GPIO_InitStructure.GPIO_Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4| //可以使用或|来进行多位的赋值 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //记得要取地址 while (1) &#123; GPIO_ResetBits(GPIOB, GPIO_Pin_12); //因为这个蜂鸣器是有源蜂鸣器，所以直接输入高电平就可以响 Delay_ms(100); GPIO_SetBits(GPIOB, GPIO_Pin_12); Delay_ms(100); &#125; [[03_2 GPIO输入]]","categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}]},{"title":"23.5.6更新","slug":"update1.0","date":"2023-05-05T16:00:00.000Z","updated":"2023-05-06T11:57:20.121Z","comments":true,"path":"2023/05/06/update1.0/","link":"","permalink":"http://example.com/2023/05/06/update1.0/","excerpt":"","text":"更新内容 新增小组件 标签 分类 新增评论系统 支持github登录 大量优化了文章阅读界面 增加站内搜索系统","categories":[{"name":"更新","slug":"更新","permalink":"http://example.com/categories/%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"关于博客","slug":"关于博客","permalink":"http://example.com/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-05-03T07:18:32.845Z","updated":"2023-05-06T10:49:57.351Z","comments":true,"path":"2023/05/03/hello-world/","link":"","permalink":"http://example.com/2023/05/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"代码","slug":"代码","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81/"}],"tags":[{"name":"关于博客","slug":"关于博客","permalink":"http://example.com/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"STM32学习","slug":"STM32学习","permalink":"http://example.com/categories/STM32%E5%AD%A6%E4%B9%A0/"},{"name":"Openmv学习","slug":"Openmv学习","permalink":"http://example.com/categories/Openmv%E5%AD%A6%E4%B9%A0/"},{"name":"更新","slug":"更新","permalink":"http://example.com/categories/%E6%9B%B4%E6%96%B0/"},{"name":"代码","slug":"代码","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"},{"name":"Openmv","slug":"Openmv","permalink":"http://example.com/tags/Openmv/"},{"name":"关于博客","slug":"关于博客","permalink":"http://example.com/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}]}